# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a DIO .NET Challenge project for an HR system (Sistema de RH) built as an ASP.NET Core 8 Web API. The system manages employee records (Funcionários) with CRUD operations and logs all changes to Azure Table Storage.

**Key Technologies:**
- .NET 8 Web API
- Entity Framework Core 8.0.18 with SQL Server Express
- Azure Table Storage for audit logging (Azurite for local development)
- Swagger/OpenAPI for API documentation

**Status:** ✅ Fully implemented and tested

## Architecture

### Data Flow
1. **SQL Database (via Entity Framework)**: Stores employee records (`Funcionario` entity)
2. **Azure Table Storage**: Stores audit logs (`FuncionarioLog` entity) for all CRUD operations
3. **Controller Layer**: [FuncionarioController.cs](Controllers/FuncionarioController.cs) handles HTTP requests and orchestrates both SQL and Azure Table operations

### Key Classes

**Funcionario** ([Models/Funcionario.cs](Models/Funcionario.cs)):
- Main entity representing an employee
- Properties: Id, Nome, Endereco, Ramal, EmailProfissional, Departamento, Salario, DataAdmissao

**FuncionarioLog** ([Models/FuncionarioLog.cs](Models/FuncionarioLog.cs)):
- Inherits from `Funcionario` and implements `ITableEntity` for Azure Table Storage
- Additional properties: TipoAcao (enum), JSON (serialized funcionario), PartitionKey, RowKey
- PartitionKey is set to the employee's department
- RowKey is a unique GUID for each log entry

**TipoAcao** ([Models/TipoAcao.cs](Models/TipoAcao.cs)):
- Enum with values: Inclusao, Atualizacao, Remocao

**RHContext** ([Context/RHContext.cs](Context/RHContext.cs)):
- Entity Framework DbContext for SQL Server
- Contains `DbSet<Funcionario>` for employee records

### Controller Pattern

The [FuncionarioController.cs](Controllers/FuncionarioController.cs) follows a dual-write pattern:
1. Performs CRUD operation on SQL Database via Entity Framework
2. Logs the action to Azure Table Storage via Azure.Data.Tables SDK

## Configuration

**Connection Strings** ([appsettings.Development.json](appsettings.Development.json)):
- `ConexaoPadrao`: SQL Server Express connection string
  - Default: `Server=localhost\\SQLEXPRESS;Database=RHDatabase;Trusted_Connection=True;TrustServerCertificate=True;MultipleActiveResultSets=true`
- `SAConnectionString`: Azure Storage connection string
  - Local development: `UseDevelopmentStorage=true` (requires Azurite)
  - Production: Azure Storage Account connection string
- `AzureTableName`: Name of the Azure Table (default: "FuncionarioLog")

**Local Development Setup:**
1. SQL Server Express must be installed and running
2. Run Azurite for local Table Storage emulation:
   ```bash
   npm install -g azurite
   azurite --silent --location c:\azurite --debug c:\azurite\debug.log
   ```

## Common Commands

### Build and Run
```bash
dotnet build
dotnet run
```

### Database Migrations
```bash
# Create a new migration
dotnet ef migrations add <MigrationName>

# Apply migrations to database
dotnet ef database update

# Remove last migration (if not applied)
dotnet ef migrations remove
```

### Access API
- Swagger UI is available at: `https://localhost:<port>/swagger` (enabled for all environments)
- API base route: `/Funcionario`

## API Endpoints

| Method | Endpoint                        | Description                              |
|--------|---------------------------------|------------------------------------------|
| GET    | /Funcionario/{id}               | Get employee by ID                       |
| POST   | /Funcionario                    | Create new employee                      |
| PUT    | /Funcionario/{id}               | Update existing employee                 |
| DELETE | /Funcionario/{id}               | Delete employee                          |
| GET    | /Funcionario/Logs               | Get all audit logs (all departments)     |
| GET    | /Funcionario/Logs/{departamento}| Get audit logs filtered by department    |

### Validation Rules

**POST /Funcionario:**
- `Nome` (required): Cannot be null or empty
- `Departamento` (required): Cannot be null or empty (used as partition key)
- `Id`: Automatically generated by database (any provided ID is ignored)

**PUT /Funcionario/{id}:**
- `Nome` (required): Cannot be null or empty
- `Departamento` (required): Cannot be null or empty
- Employee must exist (returns 404 if not found)

**DELETE /Funcionario/{id}:**
- Employee must exist (returns 404 if not found)

## ID Management and Duplication Prevention

**Auto-Generated IDs:**
- Employee IDs are automatically generated by SQL Server using `IDENTITY(1,1)`
- The database assigns sequential IDs (1, 2, 3, 4...)
- Primary key constraint prevents duplicates at the database level
- When creating employees via POST, any provided ID is ignored and reset to 0

**Why This Design:**
- Ensures data integrity and prevents ID conflicts
- Follows RESTful API best practices (server controls resource IDs)
- Users cannot bypass auto-increment or create duplicate IDs

## Audit Logging Details

**Every CRUD operation is logged to Azure Table Storage:**

**Log Structure (FuncionarioLog):**
- `TipoAcao`: 0=Inclusao (Create), 1=Atualizacao (Update), 2=Remocao (Delete)
- `PartitionKey`: Department name (enables efficient queries by department)
- `RowKey`: Unique GUID for each operation
- `JSON`: Full snapshot of employee data at the time of the operation
- `Timestamp`: When the operation occurred
- `ETag`: For concurrency control

**Querying Logs:**
- `/Funcionario/Logs` - Returns all logs across all departments
- `/Funcionario/Logs/{departamento}` - Returns logs for specific department (efficient partition query)

## Testing

**Swagger UI:** Access at `https://localhost:7090/swagger` when running locally

**Sample Test Flow:**
1. POST - Create employee "João Silva" in "TI" department
2. GET - Retrieve João's record by ID
3. GET /Logs/TI - View creation log
4. PUT - Update João's salary
5. GET /Logs/TI - View update log (should now have 2 entries)
6. DELETE - Remove João
7. GET /Logs/TI - View deletion log (should have 3 entries total)

**Verify Database:**
- Use SQL Server Management Studio or Azure Data Studio
- Connect to: `localhost\SQLEXPRESS`
- Database: `RHDatabase`
- Table: `Funcionarios`

**Verify Table Storage:**
- Option 1: Use GET `/Funcionario/Logs` endpoint
- Option 2: Install Azure Storage Explorer and connect to local emulator
- Option 3: Check `C:\azurite\__azurite_db_table__.json` file

## Implementation Status

✅ **All challenge requirements completed:**
- [x] CRUD operations for employees (POST, GET, PUT, DELETE)
- [x] SQL Server database integration with Entity Framework Core
- [x] Azure Table Storage audit logging for all operations
- [x] Dual-write pattern (SQL + Table Storage)
- [x] Proper validation (required fields, ID management)
- [x] Department-based partition strategy for efficient log queries
- [x] API documentation via Swagger
- [x] Database migrations applied
- [x] Local development environment configured (SQL Express + Azurite)

## Azure Deployment

This application is designed to be deployed to Azure with:
- **Azure App Service**: Hosts the Web API
- **Azure SQL Database**: Stores employee records
- **Azure Table Storage**: Stores audit logs

**For Production Deployment:**
1. Update `appsettings.json` connection strings:
   - `ConexaoPadrao`: Azure SQL Database connection string
   - `SAConnectionString`: Azure Storage Account connection string
2. Or use Azure App Service Configuration / Azure Key Vault for secrets
3. Ensure the database migration has been applied to Azure SQL
4. Verify Azure Table Storage account is created
